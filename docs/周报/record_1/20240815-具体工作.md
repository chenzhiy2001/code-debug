![97b0d37bcdca54597c3101123baf6ab](https://github.com/user-attachments/assets/53224ca6-a49e-4fb5-801d-9512e1234705)

### 遇到的问题
qemu虚拟机环境没用dcsr寄存器，板子上却有。
里面stepie字段可以控制单步的时候是否打开中断。
我们查看后发现stepie的值是0，那么单步的时候中断是关闭的，这个时候去单步一个会导致中断的指令无效。
### 尝试解决
#### 修改csr
我们尝试修改后发现我们板子不支持调试器修改csr
如果调用openocd的set_reg命令修改dcsr寄存器值，不仅寄存器的值不会改变，而且还会出现一个提示，说正在关闭csr寄存器的写入功能。
#### 更换边界断点位置
ecall之后不会立马切换页表，我们尝试把边界断点设置到ecall中断的中断处理函数上面。用户态断点保存在我们设定的断点组里面也不会丢，操作系统页表刷新以后再把断点加回来。在我们这个os中，ecall的中断处理函数刚好在跳板页里，跳板页是不论内核态还是用户态都可以访问的，且不论内核态还是用户态，跳板页的虚拟地址都是一样的，所以这个思路是可行的。
现在的问题是，中断处理函数是写在trampoline.S这个汇编语言文件里的，GDB无法根据内核符号表定位到这个汇编文件，GDB根据内核符号表只能定位到c语言的源代码文件，奇怪的是，有一个用户态程序是直接由一个汇编代码文件编译生成，GDB却可以定位到。
我们尝试修改汇编器和链接器的编译参数都没用
